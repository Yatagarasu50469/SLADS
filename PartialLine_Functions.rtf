{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf600
{\fonttbl\f0\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\margl1440\margr1440\vieww27960\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl280\partightenfactor0

\f0\fs24 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 def findNewMeasurementIdxs(num_threads, Mask,MeasuredIdxs,UnMeasuredIdxs,MeasuredValues,Theta,SizeImage,TrainingInfoObject,Resolution,ImageType,NumSamples,UpdateERDParamsObject,ReconValues,ReconImage,ERDValues,BatchSamplingParams,lineScanning,InitialMaskObject):\
    NewIdxs = []\
    MaxIdxsVect = []\
    if not lineScanning:\
        for i in range(0,BatchSamplingParams.NumSamplesPerIter): #For the number of pixels to sample\
            MaxIdxValue = np.nanargmax(ERDValues) #Choose the maximal ERD pixel\
            ERDValues[MaxIdxValue] = np.nan #Remove the value from future consideration\
            NewIdxs.append(UnMeasuredIdxs[MaxIdxValue].tolist()) #Add the positions to scan to the list\
            MaxIdxsVect.append(MaxIdxValue)\
    else: #lineScanning\
        backgroundThreshold = filters.threshold_otsu(ReconImage)\
        ERDValuesNP = np.empty([SizeImage[0],SizeImage[1]])\
        ERDValuesNP[:] = np.nan\
        for i in range(0, len(UnMeasuredIdxs)): \
            ERDValuesNP[UnMeasuredIdxs[i][0], UnMeasuredIdxs[i][1]] = ERDValues[i]\
        if not InitialMaskObject.MaskType == 'M':\
            if InitialMaskObject.useERDmean:\
                lineToScanIdx = np.nanargmax(np.nanmean(ERDValuesNP,axis=1)) #Choose the row with the greatest mean ERD, ignore nan rows\
            else:\
                lineToScanIdx = np.nanargmax(np.nansum(ERDValuesNP,axis=1)) #Choose the row with the greatest sum ERD, ignore nan rows\
            for i in range(0,SizeImage[1]): \
                NewIdxs.append([lineToScanIdx, i])\
        else: #Manual angle selected\
            ERDLevels = []\
            for line in InitialMaskObject.linesToScan:\
                lineERDValues = []\
                for pt in line:\
                    if InitialMaskObject.partialLine:\
                        if ReconImage[tuple(pt)] >= backgroundThreshold:\
                            lineERDValues.append(ERDValuesNP[tuple(pt)])\
                    else:\
                        lineERDValues.append(ERDValuesNP[tuple(pt)])\
                if InitialMaskObject.useERDmean:\
                    ERDLevels.append(np.nanmean(lineERDValues))\
                else: #Use summation\
                    ERDLevels.append(np.nansum(lineERDValues))\
            lineToScanIdx = np.nanargmax(ERDLevels)\
            NewIdxs = InitialMaskObject.linesToScan[lineToScanIdx]\
            \
            if InitialMaskObject.partialLine:\
                limNewIdxs = []\
                for idx in NewIdxs:\
                    if ReconImage[tuple(idx)] >= backgroundThreshold:\
                        limNewIdxs.append(idx)\
                NewIdxs = limNewIdxs\
            \
            if len(NewIdxs) <= 0: #No new points were found distinct from the background in the reconstruction\
                #Find the largest capturable area from the reconstruction\
                img = Image.fromarray(ReconImage.astype('uint8'))\
                test = np.asarray(img.convert('RGB')).copy()\
                backup = np.zeros([SizeImage[0],SizeImage[1]]).astype('uint8')\
                test = cv2.cvtColor(test,cv2.COLOR_BGR2GRAY)\
                contours, hierarchy = cv2.findContours(test, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE) \
                areas = [cv2.contourArea(c) for c in contours]\
                testResult = cv2.drawContours(np.asarray(backup), [contours[np.argmax(areas)]], -1, (255, 255, 255), -1)\
                testResult = (testResult == 255)\
\
                #For each line determine how many points intersect with that area, and scan the line with the most ERD\
                #Also determine the line with the maximum ERD in case the former yields no results\
                \
                if InitialMaskObject.useERDmean:\
                    lineToScan = InitialMaskObject.linesToScan[np.nanargmax(np.nanmean(ERDValuesNP,axis=1))]#Choose the row with the greatest mean ERD, ignore nan rows\
                else:\
                    lineToScan = InitialMaskObject.linesToScan[np.nanargmax(np.nansum(ERDValuesNP,axis=1))] #Choose the row with the greatest sum ERD, ignore nan rows\
                \
                result = Parallel(n_jobs=num_threads)(delayed(idxFinder_parhelper)(InitialMaskObject, ERDValuesNP, testResult, lineToScan, lineNum) for lineNum in tqdm(range(0,len(InitialMaskObject.linesToScan)), desc = 'idxFinder', leave = False))\
                \
                totalPtsList = []\
                sumPtsERD = []\
                meanPtsERD = []\
                ERDPtsToScan = []\
                for lineResult in result:\
                    if len(lineResult[0]) > 0:\
                        ERDPtsToScan = lineResult[0]\
                    sumPtsERD.append(lineResult[1])\
                    totalPtsList.append(lineResult[2])\
                    if len(lineResult[2]) > 0:\
                        meanPtsERD.append(lineResult[1]/len(lineResult[2]))\
                    else:\
                        meanPtsERD.append(np.nan)\
                if not np.isnan(sumPtsERD).all(): #If points were found\
                    if InitialMaskObject.partialLine:\
                        if InitialMaskObject.useERDmean:\
                            NewIdxs = totalPtsList[np.nanargmax(meanPtsERD)]\
                        else:\
                            NewIdxs = totalPtsList[np.nanargmax(sumPtsERD)]\
                    else: \
                        sys.error('Error!!! - Full linescanning entered partial linescanning code.')\
                else: #There were no new points found through this method either\
                    #Revert to full line scanning...\
                    NewIdxs = ERDPtsToScan\
                    \
        if InitialMaskObject.partialLine:\
            InitialMaskObject.delPoints(NewIdxs)\
        else:\
            InitialMaskObject.delLine(lineToScanIdx)\
\
        for k in range(0, len(NewIdxs)):\
            pt = np.asarray(NewIdxs).tolist()[k]\
            if pt in UnMeasuredIdxs.tolist():\
                MaxIdxsVect.append(UnMeasuredIdxs.tolist().index(pt))\
\
    NewIdxs = np.asarray(NewIdxs) #Actual coordinates to measure next\
    MaxIdxsVect = np.asarray(MaxIdxsVect) #Positions of those coordinates within the unmeasured listing\
\
    return(NewIdxs,MaxIdxsVect)\
\
\
\
def idxFinder_parhelper(InitialMaskObject, ERDValuesNP, testResult, lineToScan, lineNum):\
    line = InitialMaskObject.linesToScan[lineNum]\
    ERDPtsToScan = []\
    sumLineERDValue = np.nan\
    ptsList = []\
    for pt in line:\
        if pt in lineToScan:\
            ERDPtsToScan.append(pt)\
        if testResult[tuple(pt)]:\
            if np.isnan(sumLineERDValue):\
                sumLineERDValue = ERDValuesNP[tuple(pt)]\
            else:\
                sumLineERDValue = sumLineERDValue + ERDValuesNP[tuple(pt)]\
            ptsList.append(pt)\
    return ERDPtsToScan, sumLineERDValue, ptsList\
}